// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Group.proto

#ifndef PROTOBUF_IM_2eGroup_2eproto__INCLUDED
#define PROTOBUF_IM_2eGroup_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Group {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eGroup_2eproto();
void protobuf_AssignDesc_IM_2eGroup_2eproto();
void protobuf_ShutdownFile_IM_2eGroup_2eproto();

class IMNormalGroupListReq;
class IMNormalGroupListRsp;
class IMGroupInfoListReq;
class IMGroupInfoListRsp;
class IMGroupCreateReq;
class IMGroupCreateRsp;
class IMGroupChangeMemberReq;
class IMGroupChangeMemberRsp;
class IMGroupShieldReq;
class IMGroupShieldRsp;
class IMGroupChangeMemberNotify;

// ===================================================================

class IMNormalGroupListReq : public ::google::protobuf::MessageLite {
 public:
  IMNormalGroupListReq();
  virtual ~IMNormalGroupListReq();

  IMNormalGroupListReq(const IMNormalGroupListReq& from);

  inline IMNormalGroupListReq& operator=(const IMNormalGroupListReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMNormalGroupListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMNormalGroupListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMNormalGroupListReq* other);

  // implements Message ----------------------------------------------

  IMNormalGroupListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMNormalGroupListReq& from);
  void MergeFrom(const IMNormalGroupListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMNormalGroupListReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMNormalGroupListReq* default_instance_;
};
// -------------------------------------------------------------------

class IMNormalGroupListRsp : public ::google::protobuf::MessageLite {
 public:
  IMNormalGroupListRsp();
  virtual ~IMNormalGroupListRsp();

  IMNormalGroupListRsp(const IMNormalGroupListRsp& from);

  inline IMNormalGroupListRsp& operator=(const IMNormalGroupListRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMNormalGroupListRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMNormalGroupListRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMNormalGroupListRsp* other);

  // implements Message ----------------------------------------------

  IMNormalGroupListRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMNormalGroupListRsp& from);
  void MergeFrom(const IMNormalGroupListRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.GroupVersionInfo group_version_list = 2;
  inline int group_version_list_size() const;
  inline void clear_group_version_list();
  static const int kGroupVersionListFieldNumber = 2;
  inline const ::IM::BaseDefine::GroupVersionInfo& group_version_list(int index) const;
  inline ::IM::BaseDefine::GroupVersionInfo* mutable_group_version_list(int index);
  inline ::IM::BaseDefine::GroupVersionInfo* add_group_version_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo >&
      group_version_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo >*
      mutable_group_version_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMNormalGroupListRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo > group_version_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMNormalGroupListRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupInfoListReq : public ::google::protobuf::MessageLite {
 public:
  IMGroupInfoListReq();
  virtual ~IMGroupInfoListReq();

  IMGroupInfoListReq(const IMGroupInfoListReq& from);

  inline IMGroupInfoListReq& operator=(const IMGroupInfoListReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupInfoListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupInfoListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupInfoListReq* other);

  // implements Message ----------------------------------------------

  IMGroupInfoListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupInfoListReq& from);
  void MergeFrom(const IMGroupInfoListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.GroupVersionInfo group_version_list = 2;
  inline int group_version_list_size() const;
  inline void clear_group_version_list();
  static const int kGroupVersionListFieldNumber = 2;
  inline const ::IM::BaseDefine::GroupVersionInfo& group_version_list(int index) const;
  inline ::IM::BaseDefine::GroupVersionInfo* mutable_group_version_list(int index);
  inline ::IM::BaseDefine::GroupVersionInfo* add_group_version_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo >&
      group_version_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo >*
      mutable_group_version_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupInfoListReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo > group_version_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupInfoListReq* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupInfoListRsp : public ::google::protobuf::MessageLite {
 public:
  IMGroupInfoListRsp();
  virtual ~IMGroupInfoListRsp();

  IMGroupInfoListRsp(const IMGroupInfoListRsp& from);

  inline IMGroupInfoListRsp& operator=(const IMGroupInfoListRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupInfoListRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupInfoListRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupInfoListRsp* other);

  // implements Message ----------------------------------------------

  IMGroupInfoListRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupInfoListRsp& from);
  void MergeFrom(const IMGroupInfoListRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.GroupInfo group_info_list = 2;
  inline int group_info_list_size() const;
  inline void clear_group_info_list();
  static const int kGroupInfoListFieldNumber = 2;
  inline const ::IM::BaseDefine::GroupInfo& group_info_list(int index) const;
  inline ::IM::BaseDefine::GroupInfo* mutable_group_info_list(int index);
  inline ::IM::BaseDefine::GroupInfo* add_group_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupInfo >&
      group_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupInfo >*
      mutable_group_info_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupInfoListRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupInfo > group_info_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupInfoListRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupCreateReq : public ::google::protobuf::MessageLite {
 public:
  IMGroupCreateReq();
  virtual ~IMGroupCreateReq();

  IMGroupCreateReq(const IMGroupCreateReq& from);

  inline IMGroupCreateReq& operator=(const IMGroupCreateReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupCreateReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupCreateReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupCreateReq* other);

  // implements Message ----------------------------------------------

  IMGroupCreateReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupCreateReq& from);
  void MergeFrom(const IMGroupCreateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.GroupType group_type = 2 [default = GROUP_TYPE_TMP];
  inline bool has_group_type() const;
  inline void clear_group_type();
  static const int kGroupTypeFieldNumber = 2;
  inline ::IM::BaseDefine::GroupType group_type() const;
  inline void set_group_type(::IM::BaseDefine::GroupType value);

  // required string group_name = 3;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required string group_avatar = 4;
  inline bool has_group_avatar() const;
  inline void clear_group_avatar();
  static const int kGroupAvatarFieldNumber = 4;
  inline const ::std::string& group_avatar() const;
  inline void set_group_avatar(const ::std::string& value);
  inline void set_group_avatar(const char* value);
  inline void set_group_avatar(const char* value, size_t size);
  inline ::std::string* mutable_group_avatar();
  inline ::std::string* release_group_avatar();
  inline void set_allocated_group_avatar(::std::string* group_avatar);

  // repeated uint32 member_id_list = 5;
  inline int member_id_list_size() const;
  inline void clear_member_id_list();
  static const int kMemberIdListFieldNumber = 5;
  inline ::google::protobuf::uint32 member_id_list(int index) const;
  inline void set_member_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_member_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      member_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_member_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupCreateReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_type();
  inline void clear_has_group_type();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_avatar();
  inline void clear_has_group_avatar();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::uint32 user_id_;
  int group_type_;
  ::std::string* group_name_;
  ::std::string* group_avatar_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > member_id_list_;
  ::std::string* attach_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupCreateReq* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupCreateRsp : public ::google::protobuf::MessageLite {
 public:
  IMGroupCreateRsp();
  virtual ~IMGroupCreateRsp();

  IMGroupCreateRsp(const IMGroupCreateRsp& from);

  inline IMGroupCreateRsp& operator=(const IMGroupCreateRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupCreateRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupCreateRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupCreateRsp* other);

  // implements Message ----------------------------------------------

  IMGroupCreateRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupCreateRsp& from);
  void MergeFrom(const IMGroupCreateRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional uint32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required string group_name = 4;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 4;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // repeated uint32 user_id_list = 5;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 5;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupCreateRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* group_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupCreateRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupChangeMemberReq : public ::google::protobuf::MessageLite {
 public:
  IMGroupChangeMemberReq();
  virtual ~IMGroupChangeMemberReq();

  IMGroupChangeMemberReq(const IMGroupChangeMemberReq& from);

  inline IMGroupChangeMemberReq& operator=(const IMGroupChangeMemberReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupChangeMemberReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupChangeMemberReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupChangeMemberReq* other);

  // implements Message ----------------------------------------------

  IMGroupChangeMemberReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupChangeMemberReq& from);
  void MergeFrom(const IMGroupChangeMemberReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.GroupModifyType change_type = 2;
  inline bool has_change_type() const;
  inline void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  inline ::IM::BaseDefine::GroupModifyType change_type() const;
  inline void set_change_type(::IM::BaseDefine::GroupModifyType value);

  // required uint32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated uint32 member_id_list = 4;
  inline int member_id_list_size() const;
  inline void clear_member_id_list();
  static const int kMemberIdListFieldNumber = 4;
  inline ::google::protobuf::uint32 member_id_list(int index) const;
  inline void set_member_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_member_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      member_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_member_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupChangeMemberReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_change_type();
  inline void clear_has_change_type();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::uint32 user_id_;
  int change_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > member_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupChangeMemberReq* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupChangeMemberRsp : public ::google::protobuf::MessageLite {
 public:
  IMGroupChangeMemberRsp();
  virtual ~IMGroupChangeMemberRsp();

  IMGroupChangeMemberRsp(const IMGroupChangeMemberRsp& from);

  inline IMGroupChangeMemberRsp& operator=(const IMGroupChangeMemberRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupChangeMemberRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupChangeMemberRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupChangeMemberRsp* other);

  // implements Message ----------------------------------------------

  IMGroupChangeMemberRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupChangeMemberRsp& from);
  void MergeFrom(const IMGroupChangeMemberRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.GroupModifyType change_type = 2;
  inline bool has_change_type() const;
  inline void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  inline ::IM::BaseDefine::GroupModifyType change_type() const;
  inline void set_change_type(::IM::BaseDefine::GroupModifyType value);

  // required uint32 result_code = 3;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required uint32 group_id = 4;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 4;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated uint32 cur_user_id_list = 5;
  inline int cur_user_id_list_size() const;
  inline void clear_cur_user_id_list();
  static const int kCurUserIdListFieldNumber = 5;
  inline ::google::protobuf::uint32 cur_user_id_list(int index) const;
  inline void set_cur_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_cur_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cur_user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cur_user_id_list();

  // repeated uint32 chg_user_id_list = 6;
  inline int chg_user_id_list_size() const;
  inline void clear_chg_user_id_list();
  static const int kChgUserIdListFieldNumber = 6;
  inline ::google::protobuf::uint32 chg_user_id_list(int index) const;
  inline void set_chg_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_chg_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      chg_user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_chg_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupChangeMemberRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_change_type();
  inline void clear_has_change_type();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::uint32 user_id_;
  int change_type_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cur_user_id_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > chg_user_id_list_;
  ::std::string* attach_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupChangeMemberRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupShieldReq : public ::google::protobuf::MessageLite {
 public:
  IMGroupShieldReq();
  virtual ~IMGroupShieldReq();

  IMGroupShieldReq(const IMGroupShieldReq& from);

  inline IMGroupShieldReq& operator=(const IMGroupShieldReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupShieldReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupShieldReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupShieldReq* other);

  // implements Message ----------------------------------------------

  IMGroupShieldReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupShieldReq& from);
  void MergeFrom(const IMGroupShieldReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 shield_status = 3;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupShieldReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 group_id_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 shield_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupShieldReq* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupShieldRsp : public ::google::protobuf::MessageLite {
 public:
  IMGroupShieldRsp();
  virtual ~IMGroupShieldRsp();

  IMGroupShieldRsp(const IMGroupShieldRsp& from);

  inline IMGroupShieldRsp& operator=(const IMGroupShieldRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupShieldRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupShieldRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupShieldRsp* other);

  // implements Message ----------------------------------------------

  IMGroupShieldRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupShieldRsp& from);
  void MergeFrom(const IMGroupShieldRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 3;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupShieldRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 group_id_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupShieldRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupChangeMemberNotify : public ::google::protobuf::MessageLite {
 public:
  IMGroupChangeMemberNotify();
  virtual ~IMGroupChangeMemberNotify();

  IMGroupChangeMemberNotify(const IMGroupChangeMemberNotify& from);

  inline IMGroupChangeMemberNotify& operator=(const IMGroupChangeMemberNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const IMGroupChangeMemberNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupChangeMemberNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupChangeMemberNotify* other);

  // implements Message ----------------------------------------------

  IMGroupChangeMemberNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupChangeMemberNotify& from);
  void MergeFrom(const IMGroupChangeMemberNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.GroupModifyType change_type = 2;
  inline bool has_change_type() const;
  inline void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  inline ::IM::BaseDefine::GroupModifyType change_type() const;
  inline void set_change_type(::IM::BaseDefine::GroupModifyType value);

  // required uint32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated uint32 cur_user_id_list = 4;
  inline int cur_user_id_list_size() const;
  inline void clear_cur_user_id_list();
  static const int kCurUserIdListFieldNumber = 4;
  inline ::google::protobuf::uint32 cur_user_id_list(int index) const;
  inline void set_cur_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_cur_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cur_user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cur_user_id_list();

  // repeated uint32 chg_user_id_list = 5;
  inline int chg_user_id_list_size() const;
  inline void clear_chg_user_id_list();
  static const int kChgUserIdListFieldNumber = 5;
  inline ::google::protobuf::uint32 chg_user_id_list(int index) const;
  inline void set_chg_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_chg_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      chg_user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_chg_user_id_list();

  // @@protoc_insertion_point(class_scope:IM.Group.IMGroupChangeMemberNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_change_type();
  inline void clear_has_change_type();
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::uint32 user_id_;
  int change_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cur_user_id_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > chg_user_id_list_;
  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eGroup_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eGroup_2eproto();
  friend void protobuf_ShutdownFile_IM_2eGroup_2eproto();

  void InitAsDefaultInstance();
  static IMGroupChangeMemberNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// IMNormalGroupListReq

// required uint32 user_id = 1;
inline bool IMNormalGroupListReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMNormalGroupListReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMNormalGroupListReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMNormalGroupListReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMNormalGroupListReq::user_id() const {
  return user_id_;
}
inline void IMNormalGroupListReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional bytes attach_data = 20;
inline bool IMNormalGroupListReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMNormalGroupListReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMNormalGroupListReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMNormalGroupListReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMNormalGroupListReq::attach_data() const {
  return *attach_data_;
}
inline void IMNormalGroupListReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMNormalGroupListReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMNormalGroupListReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMNormalGroupListReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMNormalGroupListReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMNormalGroupListReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMNormalGroupListRsp

// required uint32 user_id = 1;
inline bool IMNormalGroupListRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMNormalGroupListRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMNormalGroupListRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMNormalGroupListRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMNormalGroupListRsp::user_id() const {
  return user_id_;
}
inline void IMNormalGroupListRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated .IM.BaseDefine.GroupVersionInfo group_version_list = 2;
inline int IMNormalGroupListRsp::group_version_list_size() const {
  return group_version_list_.size();
}
inline void IMNormalGroupListRsp::clear_group_version_list() {
  group_version_list_.Clear();
}
inline const ::IM::BaseDefine::GroupVersionInfo& IMNormalGroupListRsp::group_version_list(int index) const {
  return group_version_list_.Get(index);
}
inline ::IM::BaseDefine::GroupVersionInfo* IMNormalGroupListRsp::mutable_group_version_list(int index) {
  return group_version_list_.Mutable(index);
}
inline ::IM::BaseDefine::GroupVersionInfo* IMNormalGroupListRsp::add_group_version_list() {
  return group_version_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo >&
IMNormalGroupListRsp::group_version_list() const {
  return group_version_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo >*
IMNormalGroupListRsp::mutable_group_version_list() {
  return &group_version_list_;
}

// optional bytes attach_data = 20;
inline bool IMNormalGroupListRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMNormalGroupListRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMNormalGroupListRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMNormalGroupListRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMNormalGroupListRsp::attach_data() const {
  return *attach_data_;
}
inline void IMNormalGroupListRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMNormalGroupListRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMNormalGroupListRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMNormalGroupListRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMNormalGroupListRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMNormalGroupListRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupInfoListReq

// required uint32 user_id = 1;
inline bool IMGroupInfoListReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupInfoListReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupInfoListReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupInfoListReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupInfoListReq::user_id() const {
  return user_id_;
}
inline void IMGroupInfoListReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated .IM.BaseDefine.GroupVersionInfo group_version_list = 2;
inline int IMGroupInfoListReq::group_version_list_size() const {
  return group_version_list_.size();
}
inline void IMGroupInfoListReq::clear_group_version_list() {
  group_version_list_.Clear();
}
inline const ::IM::BaseDefine::GroupVersionInfo& IMGroupInfoListReq::group_version_list(int index) const {
  return group_version_list_.Get(index);
}
inline ::IM::BaseDefine::GroupVersionInfo* IMGroupInfoListReq::mutable_group_version_list(int index) {
  return group_version_list_.Mutable(index);
}
inline ::IM::BaseDefine::GroupVersionInfo* IMGroupInfoListReq::add_group_version_list() {
  return group_version_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo >&
IMGroupInfoListReq::group_version_list() const {
  return group_version_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupVersionInfo >*
IMGroupInfoListReq::mutable_group_version_list() {
  return &group_version_list_;
}

// optional bytes attach_data = 20;
inline bool IMGroupInfoListReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupInfoListReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupInfoListReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupInfoListReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGroupInfoListReq::attach_data() const {
  return *attach_data_;
}
inline void IMGroupInfoListReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupInfoListReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupInfoListReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupInfoListReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMGroupInfoListReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupInfoListReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupInfoListRsp

// required uint32 user_id = 1;
inline bool IMGroupInfoListRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupInfoListRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupInfoListRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupInfoListRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupInfoListRsp::user_id() const {
  return user_id_;
}
inline void IMGroupInfoListRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated .IM.BaseDefine.GroupInfo group_info_list = 2;
inline int IMGroupInfoListRsp::group_info_list_size() const {
  return group_info_list_.size();
}
inline void IMGroupInfoListRsp::clear_group_info_list() {
  group_info_list_.Clear();
}
inline const ::IM::BaseDefine::GroupInfo& IMGroupInfoListRsp::group_info_list(int index) const {
  return group_info_list_.Get(index);
}
inline ::IM::BaseDefine::GroupInfo* IMGroupInfoListRsp::mutable_group_info_list(int index) {
  return group_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::GroupInfo* IMGroupInfoListRsp::add_group_info_list() {
  return group_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupInfo >&
IMGroupInfoListRsp::group_info_list() const {
  return group_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupInfo >*
IMGroupInfoListRsp::mutable_group_info_list() {
  return &group_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMGroupInfoListRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupInfoListRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupInfoListRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupInfoListRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGroupInfoListRsp::attach_data() const {
  return *attach_data_;
}
inline void IMGroupInfoListRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupInfoListRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupInfoListRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupInfoListRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMGroupInfoListRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupInfoListRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupCreateReq

// required uint32 user_id = 1;
inline bool IMGroupCreateReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupCreateReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupCreateReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupCreateReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupCreateReq::user_id() const {
  return user_id_;
}
inline void IMGroupCreateReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .IM.BaseDefine.GroupType group_type = 2 [default = GROUP_TYPE_TMP];
inline bool IMGroupCreateReq::has_group_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGroupCreateReq::set_has_group_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGroupCreateReq::clear_has_group_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGroupCreateReq::clear_group_type() {
  group_type_ = 2;
  clear_has_group_type();
}
inline ::IM::BaseDefine::GroupType IMGroupCreateReq::group_type() const {
  return static_cast< ::IM::BaseDefine::GroupType >(group_type_);
}
inline void IMGroupCreateReq::set_group_type(::IM::BaseDefine::GroupType value) {
  assert(::IM::BaseDefine::GroupType_IsValid(value));
  set_has_group_type();
  group_type_ = value;
}

// required string group_name = 3;
inline bool IMGroupCreateReq::has_group_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupCreateReq::set_has_group_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupCreateReq::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupCreateReq::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& IMGroupCreateReq::group_name() const {
  return *group_name_;
}
inline void IMGroupCreateReq::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void IMGroupCreateReq::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void IMGroupCreateReq::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupCreateReq::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* IMGroupCreateReq::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupCreateReq::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string group_avatar = 4;
inline bool IMGroupCreateReq::has_group_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMGroupCreateReq::set_has_group_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMGroupCreateReq::clear_has_group_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMGroupCreateReq::clear_group_avatar() {
  if (group_avatar_ != &::google::protobuf::internal::kEmptyString) {
    group_avatar_->clear();
  }
  clear_has_group_avatar();
}
inline const ::std::string& IMGroupCreateReq::group_avatar() const {
  return *group_avatar_;
}
inline void IMGroupCreateReq::set_group_avatar(const ::std::string& value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::kEmptyString) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
}
inline void IMGroupCreateReq::set_group_avatar(const char* value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::kEmptyString) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
}
inline void IMGroupCreateReq::set_group_avatar(const char* value, size_t size) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::kEmptyString) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupCreateReq::mutable_group_avatar() {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::kEmptyString) {
    group_avatar_ = new ::std::string;
  }
  return group_avatar_;
}
inline ::std::string* IMGroupCreateReq::release_group_avatar() {
  clear_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_avatar_;
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupCreateReq::set_allocated_group_avatar(::std::string* group_avatar) {
  if (group_avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete group_avatar_;
  }
  if (group_avatar) {
    set_has_group_avatar();
    group_avatar_ = group_avatar;
  } else {
    clear_has_group_avatar();
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 member_id_list = 5;
inline int IMGroupCreateReq::member_id_list_size() const {
  return member_id_list_.size();
}
inline void IMGroupCreateReq::clear_member_id_list() {
  member_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMGroupCreateReq::member_id_list(int index) const {
  return member_id_list_.Get(index);
}
inline void IMGroupCreateReq::set_member_id_list(int index, ::google::protobuf::uint32 value) {
  member_id_list_.Set(index, value);
}
inline void IMGroupCreateReq::add_member_id_list(::google::protobuf::uint32 value) {
  member_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGroupCreateReq::member_id_list() const {
  return member_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGroupCreateReq::mutable_member_id_list() {
  return &member_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMGroupCreateReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMGroupCreateReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMGroupCreateReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMGroupCreateReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGroupCreateReq::attach_data() const {
  return *attach_data_;
}
inline void IMGroupCreateReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupCreateReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupCreateReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupCreateReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMGroupCreateReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupCreateReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupCreateRsp

// required uint32 user_id = 1;
inline bool IMGroupCreateRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupCreateRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupCreateRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupCreateRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupCreateRsp::user_id() const {
  return user_id_;
}
inline void IMGroupCreateRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 result_code = 2;
inline bool IMGroupCreateRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGroupCreateRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGroupCreateRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGroupCreateRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMGroupCreateRsp::result_code() const {
  return result_code_;
}
inline void IMGroupCreateRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// optional uint32 group_id = 3;
inline bool IMGroupCreateRsp::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupCreateRsp::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupCreateRsp::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupCreateRsp::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 IMGroupCreateRsp::group_id() const {
  return group_id_;
}
inline void IMGroupCreateRsp::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required string group_name = 4;
inline bool IMGroupCreateRsp::has_group_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMGroupCreateRsp::set_has_group_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMGroupCreateRsp::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMGroupCreateRsp::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& IMGroupCreateRsp::group_name() const {
  return *group_name_;
}
inline void IMGroupCreateRsp::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void IMGroupCreateRsp::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void IMGroupCreateRsp::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupCreateRsp::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* IMGroupCreateRsp::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupCreateRsp::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 user_id_list = 5;
inline int IMGroupCreateRsp::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMGroupCreateRsp::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMGroupCreateRsp::user_id_list(int index) const {
  return user_id_list_.Get(index);
}
inline void IMGroupCreateRsp::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
}
inline void IMGroupCreateRsp::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGroupCreateRsp::user_id_list() const {
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGroupCreateRsp::mutable_user_id_list() {
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMGroupCreateRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMGroupCreateRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMGroupCreateRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMGroupCreateRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGroupCreateRsp::attach_data() const {
  return *attach_data_;
}
inline void IMGroupCreateRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupCreateRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupCreateRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupCreateRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMGroupCreateRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupCreateRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupChangeMemberReq

// required uint32 user_id = 1;
inline bool IMGroupChangeMemberReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupChangeMemberReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupChangeMemberReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupChangeMemberReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberReq::user_id() const {
  return user_id_;
}
inline void IMGroupChangeMemberReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .IM.BaseDefine.GroupModifyType change_type = 2;
inline bool IMGroupChangeMemberReq::has_change_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGroupChangeMemberReq::set_has_change_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGroupChangeMemberReq::clear_has_change_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGroupChangeMemberReq::clear_change_type() {
  change_type_ = 1;
  clear_has_change_type();
}
inline ::IM::BaseDefine::GroupModifyType IMGroupChangeMemberReq::change_type() const {
  return static_cast< ::IM::BaseDefine::GroupModifyType >(change_type_);
}
inline void IMGroupChangeMemberReq::set_change_type(::IM::BaseDefine::GroupModifyType value) {
  assert(::IM::BaseDefine::GroupModifyType_IsValid(value));
  set_has_change_type();
  change_type_ = value;
}

// required uint32 group_id = 3;
inline bool IMGroupChangeMemberReq::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupChangeMemberReq::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupChangeMemberReq::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupChangeMemberReq::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberReq::group_id() const {
  return group_id_;
}
inline void IMGroupChangeMemberReq::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// repeated uint32 member_id_list = 4;
inline int IMGroupChangeMemberReq::member_id_list_size() const {
  return member_id_list_.size();
}
inline void IMGroupChangeMemberReq::clear_member_id_list() {
  member_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberReq::member_id_list(int index) const {
  return member_id_list_.Get(index);
}
inline void IMGroupChangeMemberReq::set_member_id_list(int index, ::google::protobuf::uint32 value) {
  member_id_list_.Set(index, value);
}
inline void IMGroupChangeMemberReq::add_member_id_list(::google::protobuf::uint32 value) {
  member_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGroupChangeMemberReq::member_id_list() const {
  return member_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGroupChangeMemberReq::mutable_member_id_list() {
  return &member_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMGroupChangeMemberReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMGroupChangeMemberReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMGroupChangeMemberReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMGroupChangeMemberReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGroupChangeMemberReq::attach_data() const {
  return *attach_data_;
}
inline void IMGroupChangeMemberReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupChangeMemberReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupChangeMemberReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupChangeMemberReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMGroupChangeMemberReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupChangeMemberReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupChangeMemberRsp

// required uint32 user_id = 1;
inline bool IMGroupChangeMemberRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupChangeMemberRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupChangeMemberRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupChangeMemberRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberRsp::user_id() const {
  return user_id_;
}
inline void IMGroupChangeMemberRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .IM.BaseDefine.GroupModifyType change_type = 2;
inline bool IMGroupChangeMemberRsp::has_change_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGroupChangeMemberRsp::set_has_change_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGroupChangeMemberRsp::clear_has_change_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGroupChangeMemberRsp::clear_change_type() {
  change_type_ = 1;
  clear_has_change_type();
}
inline ::IM::BaseDefine::GroupModifyType IMGroupChangeMemberRsp::change_type() const {
  return static_cast< ::IM::BaseDefine::GroupModifyType >(change_type_);
}
inline void IMGroupChangeMemberRsp::set_change_type(::IM::BaseDefine::GroupModifyType value) {
  assert(::IM::BaseDefine::GroupModifyType_IsValid(value));
  set_has_change_type();
  change_type_ = value;
}

// required uint32 result_code = 3;
inline bool IMGroupChangeMemberRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupChangeMemberRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupChangeMemberRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupChangeMemberRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberRsp::result_code() const {
  return result_code_;
}
inline void IMGroupChangeMemberRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// required uint32 group_id = 4;
inline bool IMGroupChangeMemberRsp::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMGroupChangeMemberRsp::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMGroupChangeMemberRsp::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMGroupChangeMemberRsp::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberRsp::group_id() const {
  return group_id_;
}
inline void IMGroupChangeMemberRsp::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// repeated uint32 cur_user_id_list = 5;
inline int IMGroupChangeMemberRsp::cur_user_id_list_size() const {
  return cur_user_id_list_.size();
}
inline void IMGroupChangeMemberRsp::clear_cur_user_id_list() {
  cur_user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberRsp::cur_user_id_list(int index) const {
  return cur_user_id_list_.Get(index);
}
inline void IMGroupChangeMemberRsp::set_cur_user_id_list(int index, ::google::protobuf::uint32 value) {
  cur_user_id_list_.Set(index, value);
}
inline void IMGroupChangeMemberRsp::add_cur_user_id_list(::google::protobuf::uint32 value) {
  cur_user_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGroupChangeMemberRsp::cur_user_id_list() const {
  return cur_user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGroupChangeMemberRsp::mutable_cur_user_id_list() {
  return &cur_user_id_list_;
}

// repeated uint32 chg_user_id_list = 6;
inline int IMGroupChangeMemberRsp::chg_user_id_list_size() const {
  return chg_user_id_list_.size();
}
inline void IMGroupChangeMemberRsp::clear_chg_user_id_list() {
  chg_user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberRsp::chg_user_id_list(int index) const {
  return chg_user_id_list_.Get(index);
}
inline void IMGroupChangeMemberRsp::set_chg_user_id_list(int index, ::google::protobuf::uint32 value) {
  chg_user_id_list_.Set(index, value);
}
inline void IMGroupChangeMemberRsp::add_chg_user_id_list(::google::protobuf::uint32 value) {
  chg_user_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGroupChangeMemberRsp::chg_user_id_list() const {
  return chg_user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGroupChangeMemberRsp::mutable_chg_user_id_list() {
  return &chg_user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMGroupChangeMemberRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMGroupChangeMemberRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMGroupChangeMemberRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMGroupChangeMemberRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGroupChangeMemberRsp::attach_data() const {
  return *attach_data_;
}
inline void IMGroupChangeMemberRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupChangeMemberRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupChangeMemberRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupChangeMemberRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMGroupChangeMemberRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupChangeMemberRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupShieldReq

// required uint32 user_id = 1;
inline bool IMGroupShieldReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupShieldReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupShieldReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupShieldReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupShieldReq::user_id() const {
  return user_id_;
}
inline void IMGroupShieldReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 group_id = 2;
inline bool IMGroupShieldReq::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGroupShieldReq::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGroupShieldReq::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGroupShieldReq::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 IMGroupShieldReq::group_id() const {
  return group_id_;
}
inline void IMGroupShieldReq::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required uint32 shield_status = 3;
inline bool IMGroupShieldReq::has_shield_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupShieldReq::set_has_shield_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupShieldReq::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupShieldReq::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 IMGroupShieldReq::shield_status() const {
  return shield_status_;
}
inline void IMGroupShieldReq::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
}

// optional bytes attach_data = 20;
inline bool IMGroupShieldReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMGroupShieldReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMGroupShieldReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMGroupShieldReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGroupShieldReq::attach_data() const {
  return *attach_data_;
}
inline void IMGroupShieldReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupShieldReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupShieldReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupShieldReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMGroupShieldReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupShieldReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupShieldRsp

// required uint32 user_id = 1;
inline bool IMGroupShieldRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupShieldRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupShieldRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupShieldRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupShieldRsp::user_id() const {
  return user_id_;
}
inline void IMGroupShieldRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 group_id = 2;
inline bool IMGroupShieldRsp::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGroupShieldRsp::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGroupShieldRsp::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGroupShieldRsp::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 IMGroupShieldRsp::group_id() const {
  return group_id_;
}
inline void IMGroupShieldRsp::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required uint32 result_code = 3;
inline bool IMGroupShieldRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupShieldRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupShieldRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupShieldRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMGroupShieldRsp::result_code() const {
  return result_code_;
}
inline void IMGroupShieldRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// optional bytes attach_data = 20;
inline bool IMGroupShieldRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMGroupShieldRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMGroupShieldRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMGroupShieldRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGroupShieldRsp::attach_data() const {
  return *attach_data_;
}
inline void IMGroupShieldRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupShieldRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMGroupShieldRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMGroupShieldRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMGroupShieldRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IMGroupShieldRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IMGroupChangeMemberNotify

// required uint32 user_id = 1;
inline bool IMGroupChangeMemberNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupChangeMemberNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupChangeMemberNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupChangeMemberNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberNotify::user_id() const {
  return user_id_;
}
inline void IMGroupChangeMemberNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .IM.BaseDefine.GroupModifyType change_type = 2;
inline bool IMGroupChangeMemberNotify::has_change_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGroupChangeMemberNotify::set_has_change_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGroupChangeMemberNotify::clear_has_change_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGroupChangeMemberNotify::clear_change_type() {
  change_type_ = 1;
  clear_has_change_type();
}
inline ::IM::BaseDefine::GroupModifyType IMGroupChangeMemberNotify::change_type() const {
  return static_cast< ::IM::BaseDefine::GroupModifyType >(change_type_);
}
inline void IMGroupChangeMemberNotify::set_change_type(::IM::BaseDefine::GroupModifyType value) {
  assert(::IM::BaseDefine::GroupModifyType_IsValid(value));
  set_has_change_type();
  change_type_ = value;
}

// required uint32 group_id = 3;
inline bool IMGroupChangeMemberNotify::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupChangeMemberNotify::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupChangeMemberNotify::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupChangeMemberNotify::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberNotify::group_id() const {
  return group_id_;
}
inline void IMGroupChangeMemberNotify::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// repeated uint32 cur_user_id_list = 4;
inline int IMGroupChangeMemberNotify::cur_user_id_list_size() const {
  return cur_user_id_list_.size();
}
inline void IMGroupChangeMemberNotify::clear_cur_user_id_list() {
  cur_user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberNotify::cur_user_id_list(int index) const {
  return cur_user_id_list_.Get(index);
}
inline void IMGroupChangeMemberNotify::set_cur_user_id_list(int index, ::google::protobuf::uint32 value) {
  cur_user_id_list_.Set(index, value);
}
inline void IMGroupChangeMemberNotify::add_cur_user_id_list(::google::protobuf::uint32 value) {
  cur_user_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGroupChangeMemberNotify::cur_user_id_list() const {
  return cur_user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGroupChangeMemberNotify::mutable_cur_user_id_list() {
  return &cur_user_id_list_;
}

// repeated uint32 chg_user_id_list = 5;
inline int IMGroupChangeMemberNotify::chg_user_id_list_size() const {
  return chg_user_id_list_.size();
}
inline void IMGroupChangeMemberNotify::clear_chg_user_id_list() {
  chg_user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMGroupChangeMemberNotify::chg_user_id_list(int index) const {
  return chg_user_id_list_.Get(index);
}
inline void IMGroupChangeMemberNotify::set_chg_user_id_list(int index, ::google::protobuf::uint32 value) {
  chg_user_id_list_.Set(index, value);
}
inline void IMGroupChangeMemberNotify::add_chg_user_id_list(::google::protobuf::uint32 value) {
  chg_user_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMGroupChangeMemberNotify::chg_user_id_list() const {
  return chg_user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMGroupChangeMemberNotify::mutable_chg_user_id_list() {
  return &chg_user_id_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Group
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eGroup_2eproto__INCLUDED
