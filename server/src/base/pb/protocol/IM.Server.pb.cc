// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Server.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.Server.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace Server {

void protobuf_ShutdownFile_IM_2eServer_2eproto() {
  delete IMStopReceivePacket::default_instance_;
  delete IMValidateReq::default_instance_;
  delete IMValidateRsp::default_instance_;
  delete IMGetDeviceTokenReq::default_instance_;
  delete IMGetDeviceTokenRsp::default_instance_;
  delete IMRoleSet::default_instance_;
  delete IMOnlineUserInfo::default_instance_;
  delete IMMsgServInfo::default_instance_;
  delete IMUserStatusUpdate::default_instance_;
  delete IMUserCntUpdate::default_instance_;
  delete IMServerKickUser::default_instance_;
  delete IMServerPCLoginStatusNotify::default_instance_;
  delete IMPushToUserReq::default_instance_;
  delete IMPushToUserRsp::default_instance_;
  delete IMGroupGetShieldReq::default_instance_;
  delete IMGroupGetShieldRsp::default_instance_;
  delete IMFileTransferReq::default_instance_;
  delete IMFileTransferRsp::default_instance_;
  delete IMFileServerIPReq::default_instance_;
  delete IMFileServerIPRsp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eServer_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eServer_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::IM::BaseDefine::protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  IMStopReceivePacket::default_instance_ = new IMStopReceivePacket();
  IMValidateReq::default_instance_ = new IMValidateReq();
  IMValidateRsp::default_instance_ = new IMValidateRsp();
  IMGetDeviceTokenReq::default_instance_ = new IMGetDeviceTokenReq();
  IMGetDeviceTokenRsp::default_instance_ = new IMGetDeviceTokenRsp();
  IMRoleSet::default_instance_ = new IMRoleSet();
  IMOnlineUserInfo::default_instance_ = new IMOnlineUserInfo();
  IMMsgServInfo::default_instance_ = new IMMsgServInfo();
  IMUserStatusUpdate::default_instance_ = new IMUserStatusUpdate();
  IMUserCntUpdate::default_instance_ = new IMUserCntUpdate();
  IMServerKickUser::default_instance_ = new IMServerKickUser();
  IMServerPCLoginStatusNotify::default_instance_ = new IMServerPCLoginStatusNotify();
  IMPushToUserReq::default_instance_ = new IMPushToUserReq();
  IMPushToUserRsp::default_instance_ = new IMPushToUserRsp();
  IMGroupGetShieldReq::default_instance_ = new IMGroupGetShieldReq();
  IMGroupGetShieldRsp::default_instance_ = new IMGroupGetShieldRsp();
  IMFileTransferReq::default_instance_ = new IMFileTransferReq();
  IMFileTransferRsp::default_instance_ = new IMFileTransferRsp();
  IMFileServerIPReq::default_instance_ = new IMFileServerIPReq();
  IMFileServerIPRsp::default_instance_ = new IMFileServerIPRsp();
  IMStopReceivePacket::default_instance_->InitAsDefaultInstance();
  IMValidateReq::default_instance_->InitAsDefaultInstance();
  IMValidateRsp::default_instance_->InitAsDefaultInstance();
  IMGetDeviceTokenReq::default_instance_->InitAsDefaultInstance();
  IMGetDeviceTokenRsp::default_instance_->InitAsDefaultInstance();
  IMRoleSet::default_instance_->InitAsDefaultInstance();
  IMOnlineUserInfo::default_instance_->InitAsDefaultInstance();
  IMMsgServInfo::default_instance_->InitAsDefaultInstance();
  IMUserStatusUpdate::default_instance_->InitAsDefaultInstance();
  IMUserCntUpdate::default_instance_->InitAsDefaultInstance();
  IMServerKickUser::default_instance_->InitAsDefaultInstance();
  IMServerPCLoginStatusNotify::default_instance_->InitAsDefaultInstance();
  IMPushToUserReq::default_instance_->InitAsDefaultInstance();
  IMPushToUserRsp::default_instance_->InitAsDefaultInstance();
  IMGroupGetShieldReq::default_instance_->InitAsDefaultInstance();
  IMGroupGetShieldRsp::default_instance_->InitAsDefaultInstance();
  IMFileTransferReq::default_instance_->InitAsDefaultInstance();
  IMFileTransferRsp::default_instance_->InitAsDefaultInstance();
  IMFileServerIPReq::default_instance_->InitAsDefaultInstance();
  IMFileServerIPRsp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eServer_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eServer_2eproto_once_);
void protobuf_AddDesc_IM_2eServer_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eServer_2eproto_once_,
                 &protobuf_AddDesc_IM_2eServer_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eServer_2eproto {
  StaticDescriptorInitializer_IM_2eServer_2eproto() {
    protobuf_AddDesc_IM_2eServer_2eproto();
  }
} static_descriptor_initializer_IM_2eServer_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int IMStopReceivePacket::kResultFieldNumber;
#endif  // !_MSC_VER

IMStopReceivePacket::IMStopReceivePacket()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMStopReceivePacket::InitAsDefaultInstance() {
}

IMStopReceivePacket::IMStopReceivePacket(const IMStopReceivePacket& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMStopReceivePacket::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMStopReceivePacket::~IMStopReceivePacket() {
  SharedDtor();
}

void IMStopReceivePacket::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMStopReceivePacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMStopReceivePacket& IMStopReceivePacket::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMStopReceivePacket* IMStopReceivePacket::default_instance_ = NULL;

IMStopReceivePacket* IMStopReceivePacket::New() const {
  return new IMStopReceivePacket;
}

void IMStopReceivePacket::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMStopReceivePacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMStopReceivePacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result(), output);
  }

}

int IMStopReceivePacket::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMStopReceivePacket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMStopReceivePacket*>(&from));
}

void IMStopReceivePacket::MergeFrom(const IMStopReceivePacket& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void IMStopReceivePacket::CopyFrom(const IMStopReceivePacket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMStopReceivePacket::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMStopReceivePacket::Swap(IMStopReceivePacket* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMStopReceivePacket::GetTypeName() const {
  return "IM.Server.IMStopReceivePacket";
}


// ===================================================================

#ifndef _MSC_VER
const int IMValidateReq::kUserNameFieldNumber;
const int IMValidateReq::kPasswordFieldNumber;
const int IMValidateReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMValidateReq::IMValidateReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMValidateReq::InitAsDefaultInstance() {
}

IMValidateReq::IMValidateReq(const IMValidateReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMValidateReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMValidateReq::~IMValidateReq() {
  SharedDtor();
}

void IMValidateReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMValidateReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMValidateReq& IMValidateReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMValidateReq* IMValidateReq::default_instance_ = NULL;

IMValidateReq* IMValidateReq::New() const {
  return new IMValidateReq;
}

void IMValidateReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::kEmptyString) {
        password_->clear();
      }
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMValidateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // required string password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMValidateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

  // required string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->password(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }

}

int IMValidateReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMValidateReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMValidateReq*>(&from));
}

void IMValidateReq::MergeFrom(const IMValidateReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMValidateReq::CopyFrom(const IMValidateReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMValidateReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMValidateReq::Swap(IMValidateReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(password_, other->password_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMValidateReq::GetTypeName() const {
  return "IM.Server.IMValidateReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMValidateRsp::kUserNameFieldNumber;
const int IMValidateRsp::kResultCodeFieldNumber;
const int IMValidateRsp::kResultStringFieldNumber;
const int IMValidateRsp::kUserInfoFieldNumber;
const int IMValidateRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMValidateRsp::IMValidateRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMValidateRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(
      ::IM::BaseDefine::UserInfo::internal_default_instance());
#else
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(&::IM::BaseDefine::UserInfo::default_instance());
#endif
}

IMValidateRsp::IMValidateRsp(const IMValidateRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMValidateRsp::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  result_code_ = 0u;
  result_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMValidateRsp::~IMValidateRsp() {
  SharedDtor();
}

void IMValidateRsp::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (result_string_ != &::google::protobuf::internal::kEmptyString) {
    delete result_string_;
  }
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_info_;
  }
}

void IMValidateRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMValidateRsp& IMValidateRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMValidateRsp* IMValidateRsp::default_instance_ = NULL;

IMValidateRsp* IMValidateRsp::New() const {
  return new IMValidateRsp;
}

void IMValidateRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    result_code_ = 0u;
    if (has_result_string()) {
      if (result_string_ != &::google::protobuf::internal::kEmptyString) {
        result_string_->clear();
      }
    }
    if (has_user_info()) {
      if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMValidateRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_result_string;
        break;
      }

      // optional string result_string = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_result_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_result_string()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_user_info;
        break;
      }

      // optional .IM.BaseDefine.UserInfo user_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMValidateRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

  // required uint32 result_code = 2;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result_code(), output);
  }

  // optional string result_string = 3;
  if (has_result_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->result_string(), output);
  }

  // optional .IM.BaseDefine.UserInfo user_info = 4;
  if (has_user_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->user_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }

}

int IMValidateRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required uint32 result_code = 2;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

    // optional string result_string = 3;
    if (has_result_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->result_string());
    }

    // optional .IM.BaseDefine.UserInfo user_info = 4;
    if (has_user_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_info());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMValidateRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMValidateRsp*>(&from));
}

void IMValidateRsp::MergeFrom(const IMValidateRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_result_string()) {
      set_result_string(from.result_string());
    }
    if (from.has_user_info()) {
      mutable_user_info()->::IM::BaseDefine::UserInfo::MergeFrom(from.user_info());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMValidateRsp::CopyFrom(const IMValidateRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMValidateRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_user_info()) {
    if (!this->user_info().IsInitialized()) return false;
  }
  return true;
}

void IMValidateRsp::Swap(IMValidateRsp* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(result_code_, other->result_code_);
    std::swap(result_string_, other->result_string_);
    std::swap(user_info_, other->user_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMValidateRsp::GetTypeName() const {
  return "IM.Server.IMValidateRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetDeviceTokenReq::kUserIdFieldNumber;
const int IMGetDeviceTokenReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetDeviceTokenReq::IMGetDeviceTokenReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMGetDeviceTokenReq::InitAsDefaultInstance() {
}

IMGetDeviceTokenReq::IMGetDeviceTokenReq(const IMGetDeviceTokenReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMGetDeviceTokenReq::SharedCtor() {
  _cached_size_ = 0;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetDeviceTokenReq::~IMGetDeviceTokenReq() {
  SharedDtor();
}

void IMGetDeviceTokenReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetDeviceTokenReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetDeviceTokenReq& IMGetDeviceTokenReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetDeviceTokenReq* IMGetDeviceTokenReq::default_instance_ = NULL;

IMGetDeviceTokenReq* IMGetDeviceTokenReq::New() const {
  return new IMGetDeviceTokenReq;
}

void IMGetDeviceTokenReq::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  user_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMGetDeviceTokenReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_user_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_user_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_user_id;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMGetDeviceTokenReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 user_id = 1;
  for (int i = 0; i < this->user_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->user_id(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }

}

int IMGetDeviceTokenReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 user_id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->user_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->user_id(i));
    }
    total_size += 1 * this->user_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetDeviceTokenReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeviceTokenReq*>(&from));
}

void IMGetDeviceTokenReq::MergeFrom(const IMGetDeviceTokenReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_id_.MergeFrom(from.user_id_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMGetDeviceTokenReq::CopyFrom(const IMGetDeviceTokenReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeviceTokenReq::IsInitialized() const {

  return true;
}

void IMGetDeviceTokenReq::Swap(IMGetDeviceTokenReq* other) {
  if (other != this) {
    user_id_.Swap(&other->user_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetDeviceTokenReq::GetTypeName() const {
  return "IM.Server.IMGetDeviceTokenReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetDeviceTokenRsp::kUserTokenInfoFieldNumber;
const int IMGetDeviceTokenRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetDeviceTokenRsp::IMGetDeviceTokenRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMGetDeviceTokenRsp::InitAsDefaultInstance() {
}

IMGetDeviceTokenRsp::IMGetDeviceTokenRsp(const IMGetDeviceTokenRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMGetDeviceTokenRsp::SharedCtor() {
  _cached_size_ = 0;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetDeviceTokenRsp::~IMGetDeviceTokenRsp() {
  SharedDtor();
}

void IMGetDeviceTokenRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetDeviceTokenRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetDeviceTokenRsp& IMGetDeviceTokenRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetDeviceTokenRsp* IMGetDeviceTokenRsp::default_instance_ = NULL;

IMGetDeviceTokenRsp* IMGetDeviceTokenRsp::New() const {
  return new IMGetDeviceTokenRsp;
}

void IMGetDeviceTokenRsp::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  user_token_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMGetDeviceTokenRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_token_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_token_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_user_token_info;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMGetDeviceTokenRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
  for (int i = 0; i < this->user_token_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user_token_info(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }

}

int IMGetDeviceTokenRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
  total_size += 1 * this->user_token_info_size();
  for (int i = 0; i < this->user_token_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_token_info(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetDeviceTokenRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeviceTokenRsp*>(&from));
}

void IMGetDeviceTokenRsp::MergeFrom(const IMGetDeviceTokenRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_token_info_.MergeFrom(from.user_token_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMGetDeviceTokenRsp::CopyFrom(const IMGetDeviceTokenRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeviceTokenRsp::IsInitialized() const {

  for (int i = 0; i < user_token_info_size(); i++) {
    if (!this->user_token_info(i).IsInitialized()) return false;
  }
  return true;
}

void IMGetDeviceTokenRsp::Swap(IMGetDeviceTokenRsp* other) {
  if (other != this) {
    user_token_info_.Swap(&other->user_token_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetDeviceTokenRsp::GetTypeName() const {
  return "IM.Server.IMGetDeviceTokenRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRoleSet::kMasterFieldNumber;
#endif  // !_MSC_VER

IMRoleSet::IMRoleSet()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMRoleSet::InitAsDefaultInstance() {
}

IMRoleSet::IMRoleSet(const IMRoleSet& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMRoleSet::SharedCtor() {
  _cached_size_ = 0;
  master_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRoleSet::~IMRoleSet() {
  SharedDtor();
}

void IMRoleSet::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMRoleSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRoleSet& IMRoleSet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMRoleSet* IMRoleSet::default_instance_ = NULL;

IMRoleSet* IMRoleSet::New() const {
  return new IMRoleSet;
}

void IMRoleSet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    master_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMRoleSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 master = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &master_)));
          set_has_master();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMRoleSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 master = 1;
  if (has_master()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->master(), output);
  }

}

int IMRoleSet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 master = 1;
    if (has_master()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->master());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRoleSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRoleSet*>(&from));
}

void IMRoleSet::MergeFrom(const IMRoleSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_master()) {
      set_master(from.master());
    }
  }
}

void IMRoleSet::CopyFrom(const IMRoleSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRoleSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMRoleSet::Swap(IMRoleSet* other) {
  if (other != this) {
    std::swap(master_, other->master_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRoleSet::GetTypeName() const {
  return "IM.Server.IMRoleSet";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOnlineUserInfo::kUserStatListFieldNumber;
#endif  // !_MSC_VER

IMOnlineUserInfo::IMOnlineUserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMOnlineUserInfo::InitAsDefaultInstance() {
}

IMOnlineUserInfo::IMOnlineUserInfo(const IMOnlineUserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMOnlineUserInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOnlineUserInfo::~IMOnlineUserInfo() {
  SharedDtor();
}

void IMOnlineUserInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOnlineUserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOnlineUserInfo& IMOnlineUserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMOnlineUserInfo* IMOnlineUserInfo::default_instance_ = NULL;

IMOnlineUserInfo* IMOnlineUserInfo::New() const {
  return new IMOnlineUserInfo;
}

void IMOnlineUserInfo::Clear() {
  user_stat_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMOnlineUserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_stat_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_stat_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_user_stat_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMOnlineUserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
  for (int i = 0; i < this->user_stat_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user_stat_list(i), output);
  }

}

int IMOnlineUserInfo::ByteSize() const {
  int total_size = 0;

  // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
  total_size += 1 * this->user_stat_list_size();
  for (int i = 0; i < this->user_stat_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_stat_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOnlineUserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOnlineUserInfo*>(&from));
}

void IMOnlineUserInfo::MergeFrom(const IMOnlineUserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_stat_list_.MergeFrom(from.user_stat_list_);
}

void IMOnlineUserInfo::CopyFrom(const IMOnlineUserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOnlineUserInfo::IsInitialized() const {

  for (int i = 0; i < user_stat_list_size(); i++) {
    if (!this->user_stat_list(i).IsInitialized()) return false;
  }
  return true;
}

void IMOnlineUserInfo::Swap(IMOnlineUserInfo* other) {
  if (other != this) {
    user_stat_list_.Swap(&other->user_stat_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOnlineUserInfo::GetTypeName() const {
  return "IM.Server.IMOnlineUserInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMMsgServInfo::kIp1FieldNumber;
const int IMMsgServInfo::kIp2FieldNumber;
const int IMMsgServInfo::kPortFieldNumber;
const int IMMsgServInfo::kMaxConnCntFieldNumber;
const int IMMsgServInfo::kCurConnCntFieldNumber;
const int IMMsgServInfo::kHostNameFieldNumber;
#endif  // !_MSC_VER

IMMsgServInfo::IMMsgServInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMMsgServInfo::InitAsDefaultInstance() {
}

IMMsgServInfo::IMMsgServInfo(const IMMsgServInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMMsgServInfo::SharedCtor() {
  _cached_size_ = 0;
  ip1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0u;
  max_conn_cnt_ = 0u;
  cur_conn_cnt_ = 0u;
  host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMMsgServInfo::~IMMsgServInfo() {
  SharedDtor();
}

void IMMsgServInfo::SharedDtor() {
  if (ip1_ != &::google::protobuf::internal::kEmptyString) {
    delete ip1_;
  }
  if (ip2_ != &::google::protobuf::internal::kEmptyString) {
    delete ip2_;
  }
  if (host_name_ != &::google::protobuf::internal::kEmptyString) {
    delete host_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMMsgServInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMMsgServInfo& IMMsgServInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMMsgServInfo* IMMsgServInfo::default_instance_ = NULL;

IMMsgServInfo* IMMsgServInfo::New() const {
  return new IMMsgServInfo;
}

void IMMsgServInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ip1()) {
      if (ip1_ != &::google::protobuf::internal::kEmptyString) {
        ip1_->clear();
      }
    }
    if (has_ip2()) {
      if (ip2_ != &::google::protobuf::internal::kEmptyString) {
        ip2_->clear();
      }
    }
    port_ = 0u;
    max_conn_cnt_ = 0u;
    cur_conn_cnt_ = 0u;
    if (has_host_name()) {
      if (host_name_ != &::google::protobuf::internal::kEmptyString) {
        host_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMMsgServInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip1 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ip2;
        break;
      }

      // required string ip2 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // required uint32 port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_max_conn_cnt;
        break;
      }

      // required uint32 max_conn_cnt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_conn_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_conn_cnt_)));
          set_has_max_conn_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_cur_conn_cnt;
        break;
      }

      // required uint32 cur_conn_cnt = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cur_conn_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cur_conn_cnt_)));
          set_has_cur_conn_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_host_name;
        break;
      }

      // required string host_name = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_host_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMMsgServInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string ip1 = 1;
  if (has_ip1()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ip1(), output);
  }

  // required string ip2 = 2;
  if (has_ip2()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->ip2(), output);
  }

  // required uint32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // required uint32 max_conn_cnt = 4;
  if (has_max_conn_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->max_conn_cnt(), output);
  }

  // required uint32 cur_conn_cnt = 5;
  if (has_cur_conn_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->cur_conn_cnt(), output);
  }

  // required string host_name = 6;
  if (has_host_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->host_name(), output);
  }

}

int IMMsgServInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ip1 = 1;
    if (has_ip1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip1());
    }

    // required string ip2 = 2;
    if (has_ip2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip2());
    }

    // required uint32 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // required uint32 max_conn_cnt = 4;
    if (has_max_conn_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_conn_cnt());
    }

    // required uint32 cur_conn_cnt = 5;
    if (has_cur_conn_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cur_conn_cnt());
    }

    // required string host_name = 6;
    if (has_host_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMMsgServInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsgServInfo*>(&from));
}

void IMMsgServInfo::MergeFrom(const IMMsgServInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip1()) {
      set_ip1(from.ip1());
    }
    if (from.has_ip2()) {
      set_ip2(from.ip2());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_max_conn_cnt()) {
      set_max_conn_cnt(from.max_conn_cnt());
    }
    if (from.has_cur_conn_cnt()) {
      set_cur_conn_cnt(from.cur_conn_cnt());
    }
    if (from.has_host_name()) {
      set_host_name(from.host_name());
    }
  }
}

void IMMsgServInfo::CopyFrom(const IMMsgServInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsgServInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void IMMsgServInfo::Swap(IMMsgServInfo* other) {
  if (other != this) {
    std::swap(ip1_, other->ip1_);
    std::swap(ip2_, other->ip2_);
    std::swap(port_, other->port_);
    std::swap(max_conn_cnt_, other->max_conn_cnt_);
    std::swap(cur_conn_cnt_, other->cur_conn_cnt_);
    std::swap(host_name_, other->host_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMMsgServInfo::GetTypeName() const {
  return "IM.Server.IMMsgServInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMUserStatusUpdate::kUserStatusFieldNumber;
const int IMUserStatusUpdate::kUserIdFieldNumber;
const int IMUserStatusUpdate::kClientTypeFieldNumber;
#endif  // !_MSC_VER

IMUserStatusUpdate::IMUserStatusUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMUserStatusUpdate::InitAsDefaultInstance() {
}

IMUserStatusUpdate::IMUserStatusUpdate(const IMUserStatusUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMUserStatusUpdate::SharedCtor() {
  _cached_size_ = 0;
  user_status_ = 0u;
  user_id_ = 0u;
  client_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserStatusUpdate::~IMUserStatusUpdate() {
  SharedDtor();
}

void IMUserStatusUpdate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserStatusUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserStatusUpdate& IMUserStatusUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMUserStatusUpdate* IMUserStatusUpdate::default_instance_ = NULL;

IMUserStatusUpdate* IMUserStatusUpdate::New() const {
  return new IMUserStatusUpdate;
}

void IMUserStatusUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_status_ = 0u;
    user_id_ = 0u;
    client_type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMUserStatusUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_status_)));
          set_has_user_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMUserStatusUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_status = 1;
  if (has_user_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_status(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 3;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->client_type(), output);
  }

}

int IMUserStatusUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_status = 1;
    if (has_user_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_status());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.ClientType client_type = 3;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserStatusUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserStatusUpdate*>(&from));
}

void IMUserStatusUpdate::MergeFrom(const IMUserStatusUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_status()) {
      set_user_status(from.user_status());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
  }
}

void IMUserStatusUpdate::CopyFrom(const IMUserStatusUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserStatusUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMUserStatusUpdate::Swap(IMUserStatusUpdate* other) {
  if (other != this) {
    std::swap(user_status_, other->user_status_);
    std::swap(user_id_, other->user_id_);
    std::swap(client_type_, other->client_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMUserStatusUpdate::GetTypeName() const {
  return "IM.Server.IMUserStatusUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int IMUserCntUpdate::kUserActionFieldNumber;
const int IMUserCntUpdate::kUserIdFieldNumber;
#endif  // !_MSC_VER

IMUserCntUpdate::IMUserCntUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMUserCntUpdate::InitAsDefaultInstance() {
}

IMUserCntUpdate::IMUserCntUpdate(const IMUserCntUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMUserCntUpdate::SharedCtor() {
  _cached_size_ = 0;
  user_action_ = 0u;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserCntUpdate::~IMUserCntUpdate() {
  SharedDtor();
}

void IMUserCntUpdate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserCntUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserCntUpdate& IMUserCntUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMUserCntUpdate* IMUserCntUpdate::default_instance_ = NULL;

IMUserCntUpdate* IMUserCntUpdate::New() const {
  return new IMUserCntUpdate;
}

void IMUserCntUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_action_ = 0u;
    user_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMUserCntUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_action = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_action_)));
          set_has_user_action();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMUserCntUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_action = 1;
  if (has_user_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_action(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

}

int IMUserCntUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_action = 1;
    if (has_user_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_action());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserCntUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserCntUpdate*>(&from));
}

void IMUserCntUpdate::MergeFrom(const IMUserCntUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_action()) {
      set_user_action(from.user_action());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
}

void IMUserCntUpdate::CopyFrom(const IMUserCntUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserCntUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMUserCntUpdate::Swap(IMUserCntUpdate* other) {
  if (other != this) {
    std::swap(user_action_, other->user_action_);
    std::swap(user_id_, other->user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMUserCntUpdate::GetTypeName() const {
  return "IM.Server.IMUserCntUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int IMServerKickUser::kUserIdFieldNumber;
const int IMServerKickUser::kClientTypeFieldNumber;
const int IMServerKickUser::kReasonFieldNumber;
#endif  // !_MSC_VER

IMServerKickUser::IMServerKickUser()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMServerKickUser::InitAsDefaultInstance() {
}

IMServerKickUser::IMServerKickUser(const IMServerKickUser& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMServerKickUser::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  client_type_ = 1;
  reason_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMServerKickUser::~IMServerKickUser() {
  SharedDtor();
}

void IMServerKickUser::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMServerKickUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMServerKickUser& IMServerKickUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMServerKickUser* IMServerKickUser::default_instance_ = NULL;

IMServerKickUser* IMServerKickUser::New() const {
  return new IMServerKickUser;
}

void IMServerKickUser::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
    client_type_ = 1;
    reason_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMServerKickUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_reason;
        break;
      }

      // required uint32 reason = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reason_)));
          set_has_reason();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMServerKickUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 2;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->client_type(), output);
  }

  // required uint32 reason = 3;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->reason(), output);
  }

}

int IMServerKickUser::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.ClientType client_type = 2;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

    // required uint32 reason = 3;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reason());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMServerKickUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMServerKickUser*>(&from));
}

void IMServerKickUser::MergeFrom(const IMServerKickUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
    if (from.has_reason()) {
      set_reason(from.reason());
    }
  }
}

void IMServerKickUser::CopyFrom(const IMServerKickUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMServerKickUser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMServerKickUser::Swap(IMServerKickUser* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(client_type_, other->client_type_);
    std::swap(reason_, other->reason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMServerKickUser::GetTypeName() const {
  return "IM.Server.IMServerKickUser";
}


// ===================================================================

#ifndef _MSC_VER
const int IMServerPCLoginStatusNotify::kUserIdFieldNumber;
const int IMServerPCLoginStatusNotify::kLoginStatusFieldNumber;
#endif  // !_MSC_VER

IMServerPCLoginStatusNotify::IMServerPCLoginStatusNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMServerPCLoginStatusNotify::InitAsDefaultInstance() {
}

IMServerPCLoginStatusNotify::IMServerPCLoginStatusNotify(const IMServerPCLoginStatusNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMServerPCLoginStatusNotify::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  login_status_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMServerPCLoginStatusNotify::~IMServerPCLoginStatusNotify() {
  SharedDtor();
}

void IMServerPCLoginStatusNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMServerPCLoginStatusNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMServerPCLoginStatusNotify& IMServerPCLoginStatusNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMServerPCLoginStatusNotify* IMServerPCLoginStatusNotify::default_instance_ = NULL;

IMServerPCLoginStatusNotify* IMServerPCLoginStatusNotify::New() const {
  return new IMServerPCLoginStatusNotify;
}

void IMServerPCLoginStatusNotify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
    login_status_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMServerPCLoginStatusNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_login_status;
        break;
      }

      // required uint32 login_status = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_login_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &login_status_)));
          set_has_login_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMServerPCLoginStatusNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 login_status = 2;
  if (has_login_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->login_status(), output);
  }

}

int IMServerPCLoginStatusNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 login_status = 2;
    if (has_login_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->login_status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMServerPCLoginStatusNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMServerPCLoginStatusNotify*>(&from));
}

void IMServerPCLoginStatusNotify::MergeFrom(const IMServerPCLoginStatusNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_login_status()) {
      set_login_status(from.login_status());
    }
  }
}

void IMServerPCLoginStatusNotify::CopyFrom(const IMServerPCLoginStatusNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMServerPCLoginStatusNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMServerPCLoginStatusNotify::Swap(IMServerPCLoginStatusNotify* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(login_status_, other->login_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMServerPCLoginStatusNotify::GetTypeName() const {
  return "IM.Server.IMServerPCLoginStatusNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int IMPushToUserReq::kFlashFieldNumber;
const int IMPushToUserReq::kDataFieldNumber;
const int IMPushToUserReq::kUserTokenListFieldNumber;
#endif  // !_MSC_VER

IMPushToUserReq::IMPushToUserReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMPushToUserReq::InitAsDefaultInstance() {
}

IMPushToUserReq::IMPushToUserReq(const IMPushToUserReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMPushToUserReq::SharedCtor() {
  _cached_size_ = 0;
  flash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMPushToUserReq::~IMPushToUserReq() {
  SharedDtor();
}

void IMPushToUserReq::SharedDtor() {
  if (flash_ != &::google::protobuf::internal::kEmptyString) {
    delete flash_;
  }
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMPushToUserReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMPushToUserReq& IMPushToUserReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMPushToUserReq* IMPushToUserReq::default_instance_ = NULL;

IMPushToUserReq* IMPushToUserReq::New() const {
  return new IMPushToUserReq;
}

void IMPushToUserReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_flash()) {
      if (flash_ != &::google::protobuf::internal::kEmptyString) {
        flash_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  user_token_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMPushToUserReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string flash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_flash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required string data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_token_list;
        break;
      }

      // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_token_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_token_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_token_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMPushToUserReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string flash = 1;
  if (has_flash()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->flash(), output);
  }

  // required string data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->data(), output);
  }

  // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
  for (int i = 0; i < this->user_token_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user_token_list(i), output);
  }

}

int IMPushToUserReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string flash = 1;
    if (has_flash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->flash());
    }

    // required string data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data());
    }

  }
  // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
  total_size += 1 * this->user_token_list_size();
  for (int i = 0; i < this->user_token_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_token_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMPushToUserReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMPushToUserReq*>(&from));
}

void IMPushToUserReq::MergeFrom(const IMPushToUserReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_token_list_.MergeFrom(from.user_token_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flash()) {
      set_flash(from.flash());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
}

void IMPushToUserReq::CopyFrom(const IMPushToUserReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPushToUserReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < user_token_list_size(); i++) {
    if (!this->user_token_list(i).IsInitialized()) return false;
  }
  return true;
}

void IMPushToUserReq::Swap(IMPushToUserReq* other) {
  if (other != this) {
    std::swap(flash_, other->flash_);
    std::swap(data_, other->data_);
    user_token_list_.Swap(&other->user_token_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMPushToUserReq::GetTypeName() const {
  return "IM.Server.IMPushToUserReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMPushToUserRsp::kPushResultListFieldNumber;
#endif  // !_MSC_VER

IMPushToUserRsp::IMPushToUserRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMPushToUserRsp::InitAsDefaultInstance() {
}

IMPushToUserRsp::IMPushToUserRsp(const IMPushToUserRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMPushToUserRsp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMPushToUserRsp::~IMPushToUserRsp() {
  SharedDtor();
}

void IMPushToUserRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMPushToUserRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMPushToUserRsp& IMPushToUserRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMPushToUserRsp* IMPushToUserRsp::default_instance_ = NULL;

IMPushToUserRsp* IMPushToUserRsp::New() const {
  return new IMPushToUserRsp;
}

void IMPushToUserRsp::Clear() {
  push_result_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMPushToUserRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.PushResult push_result_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_push_result_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_push_result_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_push_result_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMPushToUserRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .IM.BaseDefine.PushResult push_result_list = 1;
  for (int i = 0; i < this->push_result_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->push_result_list(i), output);
  }

}

int IMPushToUserRsp::ByteSize() const {
  int total_size = 0;

  // repeated .IM.BaseDefine.PushResult push_result_list = 1;
  total_size += 1 * this->push_result_list_size();
  for (int i = 0; i < this->push_result_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->push_result_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMPushToUserRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMPushToUserRsp*>(&from));
}

void IMPushToUserRsp::MergeFrom(const IMPushToUserRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  push_result_list_.MergeFrom(from.push_result_list_);
}

void IMPushToUserRsp::CopyFrom(const IMPushToUserRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPushToUserRsp::IsInitialized() const {

  for (int i = 0; i < push_result_list_size(); i++) {
    if (!this->push_result_list(i).IsInitialized()) return false;
  }
  return true;
}

void IMPushToUserRsp::Swap(IMPushToUserRsp* other) {
  if (other != this) {
    push_result_list_.Swap(&other->push_result_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMPushToUserRsp::GetTypeName() const {
  return "IM.Server.IMPushToUserRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGroupGetShieldReq::kGroupIdFieldNumber;
const int IMGroupGetShieldReq::kUserIdFieldNumber;
const int IMGroupGetShieldReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGroupGetShieldReq::IMGroupGetShieldReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMGroupGetShieldReq::InitAsDefaultInstance() {
}

IMGroupGetShieldReq::IMGroupGetShieldReq(const IMGroupGetShieldReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMGroupGetShieldReq::SharedCtor() {
  _cached_size_ = 0;
  group_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGroupGetShieldReq::~IMGroupGetShieldReq() {
  SharedDtor();
}

void IMGroupGetShieldReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGroupGetShieldReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGroupGetShieldReq& IMGroupGetShieldReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGroupGetShieldReq* IMGroupGetShieldReq::default_instance_ = NULL;

IMGroupGetShieldReq* IMGroupGetShieldReq::New() const {
  return new IMGroupGetShieldReq;
}

void IMGroupGetShieldReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    group_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  user_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMGroupGetShieldReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // repeated uint32 user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_user_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_user_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMGroupGetShieldReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // repeated uint32 user_id = 2;
  for (int i = 0; i < this->user_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->user_id(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }

}

int IMGroupGetShieldReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 user_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->user_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->user_id(i));
    }
    total_size += 1 * this->user_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGroupGetShieldReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupGetShieldReq*>(&from));
}

void IMGroupGetShieldReq::MergeFrom(const IMGroupGetShieldReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_id_.MergeFrom(from.user_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMGroupGetShieldReq::CopyFrom(const IMGroupGetShieldReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupGetShieldReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMGroupGetShieldReq::Swap(IMGroupGetShieldReq* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    user_id_.Swap(&other->user_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGroupGetShieldReq::GetTypeName() const {
  return "IM.Server.IMGroupGetShieldReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGroupGetShieldRsp::kGroupIdFieldNumber;
const int IMGroupGetShieldRsp::kShieldStatusListFieldNumber;
const int IMGroupGetShieldRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGroupGetShieldRsp::IMGroupGetShieldRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMGroupGetShieldRsp::InitAsDefaultInstance() {
}

IMGroupGetShieldRsp::IMGroupGetShieldRsp(const IMGroupGetShieldRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMGroupGetShieldRsp::SharedCtor() {
  _cached_size_ = 0;
  group_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGroupGetShieldRsp::~IMGroupGetShieldRsp() {
  SharedDtor();
}

void IMGroupGetShieldRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGroupGetShieldRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGroupGetShieldRsp& IMGroupGetShieldRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGroupGetShieldRsp* IMGroupGetShieldRsp::default_instance_ = NULL;

IMGroupGetShieldRsp* IMGroupGetShieldRsp::New() const {
  return new IMGroupGetShieldRsp;
}

void IMGroupGetShieldRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    group_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  shield_status_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMGroupGetShieldRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_shield_status_list;
        break;
      }

      // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shield_status_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shield_status_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_shield_status_list;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMGroupGetShieldRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
  for (int i = 0; i < this->shield_status_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->shield_status_list(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }

}

int IMGroupGetShieldRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
  total_size += 1 * this->shield_status_list_size();
  for (int i = 0; i < this->shield_status_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shield_status_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGroupGetShieldRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupGetShieldRsp*>(&from));
}

void IMGroupGetShieldRsp::MergeFrom(const IMGroupGetShieldRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  shield_status_list_.MergeFrom(from.shield_status_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMGroupGetShieldRsp::CopyFrom(const IMGroupGetShieldRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupGetShieldRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < shield_status_list_size(); i++) {
    if (!this->shield_status_list(i).IsInitialized()) return false;
  }
  return true;
}

void IMGroupGetShieldRsp::Swap(IMGroupGetShieldRsp* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    shield_status_list_.Swap(&other->shield_status_list_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGroupGetShieldRsp::GetTypeName() const {
  return "IM.Server.IMGroupGetShieldRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileTransferReq::kFromUserIdFieldNumber;
const int IMFileTransferReq::kToUserIdFieldNumber;
const int IMFileTransferReq::kFileNameFieldNumber;
const int IMFileTransferReq::kFileSizeFieldNumber;
const int IMFileTransferReq::kTransModeFieldNumber;
const int IMFileTransferReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMFileTransferReq::IMFileTransferReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileTransferReq::InitAsDefaultInstance() {
}

IMFileTransferReq::IMFileTransferReq(const IMFileTransferReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileTransferReq::SharedCtor() {
  _cached_size_ = 0;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_size_ = 0u;
  trans_mode_ = 1;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileTransferReq::~IMFileTransferReq() {
  SharedDtor();
}

void IMFileTransferReq::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileTransferReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileTransferReq& IMFileTransferReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileTransferReq* IMFileTransferReq::default_instance_ = NULL;

IMFileTransferReq* IMFileTransferReq::New() const {
  return new IMFileTransferReq;
}

void IMFileTransferReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    from_user_id_ = 0u;
    to_user_id_ = 0u;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    file_size_ = 0u;
    trans_mode_ = 1;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileTransferReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_file_name;
        break;
      }

      // required string file_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_file_size;
        break;
      }

      // required uint32 file_size = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_trans_mode;
        break;
      }

      // required .IM.BaseDefine.TransferFileType trans_mode = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::TransferFileType_IsValid(value)) {
            set_trans_mode(static_cast< ::IM::BaseDefine::TransferFileType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileTransferReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }

  // required uint32 to_user_id = 2;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_user_id(), output);
  }

  // required string file_name = 3;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->file_name(), output);
  }

  // required uint32 file_size = 4;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->file_size(), output);
  }

  // required .IM.BaseDefine.TransferFileType trans_mode = 5;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->trans_mode(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }

}

int IMFileTransferReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_user_id = 1;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_user_id = 2;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required string file_name = 3;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // required uint32 file_size = 4;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }

    // required .IM.BaseDefine.TransferFileType trans_mode = 5;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileTransferReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileTransferReq*>(&from));
}

void IMFileTransferReq::MergeFrom(const IMFileTransferReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMFileTransferReq::CopyFrom(const IMFileTransferReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileTransferReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void IMFileTransferReq::Swap(IMFileTransferReq* other) {
  if (other != this) {
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    std::swap(trans_mode_, other->trans_mode_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileTransferReq::GetTypeName() const {
  return "IM.Server.IMFileTransferReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileTransferRsp::kResultCodeFieldNumber;
const int IMFileTransferRsp::kFromUserIdFieldNumber;
const int IMFileTransferRsp::kToUserIdFieldNumber;
const int IMFileTransferRsp::kFileNameFieldNumber;
const int IMFileTransferRsp::kFileSizeFieldNumber;
const int IMFileTransferRsp::kTaskIdFieldNumber;
const int IMFileTransferRsp::kTransModeFieldNumber;
const int IMFileTransferRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMFileTransferRsp::IMFileTransferRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileTransferRsp::InitAsDefaultInstance() {
}

IMFileTransferRsp::IMFileTransferRsp(const IMFileTransferRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileTransferRsp::SharedCtor() {
  _cached_size_ = 0;
  result_code_ = 0u;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_size_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  trans_mode_ = 1;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileTransferRsp::~IMFileTransferRsp() {
  SharedDtor();
}

void IMFileTransferRsp::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileTransferRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileTransferRsp& IMFileTransferRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileTransferRsp* IMFileTransferRsp::default_instance_ = NULL;

IMFileTransferRsp* IMFileTransferRsp::New() const {
  return new IMFileTransferRsp;
}

void IMFileTransferRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_code_ = 0u;
    from_user_id_ = 0u;
    to_user_id_ = 0u;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    file_size_ = 0u;
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
    trans_mode_ = 1;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileTransferRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_file_name;
        break;
      }

      // optional string file_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_file_size;
        break;
      }

      // optional uint32 file_size = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_task_id;
        break;
      }

      // optional string task_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_trans_mode;
        break;
      }

      // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::TransferFileType_IsValid(value)) {
            set_trans_mode(static_cast< ::IM::BaseDefine::TransferFileType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileTransferRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result_code(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_user_id = 3;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_user_id(), output);
  }

  // optional string file_name = 4;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->file_name(), output);
  }

  // optional uint32 file_size = 5;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->file_size(), output);
  }

  // optional string task_id = 6;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->task_id(), output);
  }

  // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->trans_mode(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }

}

int IMFileTransferRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_user_id = 3;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // optional string file_name = 4;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // optional uint32 file_size = 5;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }

    // optional string task_id = 6;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }

    // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileTransferRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileTransferRsp*>(&from));
}

void IMFileTransferRsp::MergeFrom(const IMFileTransferRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMFileTransferRsp::CopyFrom(const IMFileTransferRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileTransferRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMFileTransferRsp::Swap(IMFileTransferRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    std::swap(task_id_, other->task_id_);
    std::swap(trans_mode_, other->trans_mode_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileTransferRsp::GetTypeName() const {
  return "IM.Server.IMFileTransferRsp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

IMFileServerIPReq::IMFileServerIPReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileServerIPReq::InitAsDefaultInstance() {
}

IMFileServerIPReq::IMFileServerIPReq(const IMFileServerIPReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileServerIPReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileServerIPReq::~IMFileServerIPReq() {
  SharedDtor();
}

void IMFileServerIPReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileServerIPReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileServerIPReq& IMFileServerIPReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileServerIPReq* IMFileServerIPReq::default_instance_ = NULL;

IMFileServerIPReq* IMFileServerIPReq::New() const {
  return new IMFileServerIPReq;
}

void IMFileServerIPReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileServerIPReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void IMFileServerIPReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int IMFileServerIPReq::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileServerIPReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileServerIPReq*>(&from));
}

void IMFileServerIPReq::MergeFrom(const IMFileServerIPReq& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void IMFileServerIPReq::CopyFrom(const IMFileServerIPReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileServerIPReq::IsInitialized() const {

  return true;
}

void IMFileServerIPReq::Swap(IMFileServerIPReq* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileServerIPReq::GetTypeName() const {
  return "IM.Server.IMFileServerIPReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileServerIPRsp::kIpAddrListFieldNumber;
#endif  // !_MSC_VER

IMFileServerIPRsp::IMFileServerIPRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileServerIPRsp::InitAsDefaultInstance() {
}

IMFileServerIPRsp::IMFileServerIPRsp(const IMFileServerIPRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileServerIPRsp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileServerIPRsp::~IMFileServerIPRsp() {
  SharedDtor();
}

void IMFileServerIPRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileServerIPRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileServerIPRsp& IMFileServerIPRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileServerIPRsp* IMFileServerIPRsp::default_instance_ = NULL;

IMFileServerIPRsp* IMFileServerIPRsp::New() const {
  return new IMFileServerIPRsp;
}

void IMFileServerIPRsp::Clear() {
  ip_addr_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileServerIPRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip_addr_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ip_addr_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_ip_addr_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileServerIPRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->ip_addr_list(i), output);
  }

}

int IMFileServerIPRsp::ByteSize() const {
  int total_size = 0;

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
  total_size += 1 * this->ip_addr_list_size();
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addr_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileServerIPRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileServerIPRsp*>(&from));
}

void IMFileServerIPRsp::MergeFrom(const IMFileServerIPRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  ip_addr_list_.MergeFrom(from.ip_addr_list_);
}

void IMFileServerIPRsp::CopyFrom(const IMFileServerIPRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileServerIPRsp::IsInitialized() const {

  for (int i = 0; i < ip_addr_list_size(); i++) {
    if (!this->ip_addr_list(i).IsInitialized()) return false;
  }
  return true;
}

void IMFileServerIPRsp::Swap(IMFileServerIPRsp* other) {
  if (other != this) {
    ip_addr_list_.Swap(&other->ip_addr_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileServerIPRsp::GetTypeName() const {
  return "IM.Server.IMFileServerIPRsp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Server
}  // namespace IM

// @@protoc_insertion_point(global_scope)
